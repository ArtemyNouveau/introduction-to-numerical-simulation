# Число обусловленности

[Оглавление](../README.md)

В предыдущей лекции мы отметили, что при работе с арифметикой 
с плавающей запятой имеется три основных источника ошибок:

1. Округления вещественного числа до числа с плавающей запятой 
имеет относительную погрешность равную половине машинной точности.
1. Каждая операция над числами, имеющими точное представление 
с плавающей запятой, имеет погрешность равную машинной точности.
Если операция над числами допускает округление в нужную сторону,
то погрешность может быть равна половине машинной погрешности.
1. Погрешность входных данных может увеличиться или уменьшиться
в результате выполнения операции даже в точной арифметике.

Первые два вида погрешности ограничены стандартом 
[IEEE 754](https://ru.wikipedia.org/wiki/IEEE_754-2008).
Мы остановимся на третьем виде погрешности.

Ранее мы видели, что при возведении числа с некоторой данной малой
относительной погрешностью в степень `a`, относительная погрешность
умножается на `a`.
Примененный нами способ оценки погрешности относительно сложен,
однако можно вывести более простую формулу.
Пусть нам дано `x=x0*(1+dx)` приближенно равное `x0` с относительной
погрешностью `dx`.
Вычислим значение `y=f(x)` функции `f` на аргументе `x`.
Предположим, что `f` вычисляет точно, однако результат будет иметь
погрешность, так как аргумент дан приближенно.
Пусть точное значение результата `y0=f(x0)`,
тогда `y=y0*(1+dy)`, где `dy` - погрешность результата.
Считая погрешность `dx` маленькой, а функцию `f` дифференцируемой,
оценим искомую погрешность следующим образом:

```
dy=(y-y0)/y0=(f(x0*(1+dx))-f(x0))/f(x0)=f'(x0)*x0*dx/f(x0),
```

где `f'(x0)` обозначает производную функцию в точке `x0`.
Как мы видим, погрешность `dy` результата пропорциональна 
погрешности аргумента `dx`, если погрешность `dx` мала.
Коэффициент пропорциональности `k(f,x0)` называют *числом обусловленности*.

```
k(f,x0)=|x0*f'(x0)/f(x0)|.
```

Мы вычислили число обусловленности для относительной погрешности аргумента
и результата, однако можно вычислить и другие числа обусловленности.
Например, найдем число обусловленности для абсолютной погрешности 
аргумента и результата.
Пусть дан аргумент `x=x0+dx` с абсолютной погрешностью `dx`.
Результат вычислений функции `y=f(x0)+dy=f(x)` имеет 
некую абсолютную погрешность `dy`.
Тогда `dy=f(x0)-f(x0+dx)=f'(x0)*dx`,
т.е. погрешность результата снова пропорциональна погрешности аргумента.
Коэффициент пропорциональности называют числом обусловленности для
абсолютных ошибок аргумента и результата, и мы видим,
что оно равно модулю производной в точке.

При работе с числами с плавающей запятой мы интересуемся относительными
погрешностями, поэтому будем обсуждать только число обусловленности 
для относительных погрешностей без дополнительных уточнений.
Выше мы показали, что число обусловленности зависит от величины числа,
с которым производятся операции, т.е. для функции есть область,
где вычисления проводить безопасно, но при некоторых значениях аргумента
результату нельзя доверять, причем библиотека работы с числами
с плавающей запятой не даст вам никаких предупреждений.
Число обусловленности `k` равное или меньшее единицы как правило на устраивает,
так как в этом случае точность результата равна или выше точности аргумента.
Если `k` больше единицы, то точность результат падает при вычислениях.
Обычно выделяют хорошо обусловленные задачи с малыми числами обусловленности,
и плохо обусловленные задачи, для которых числа обусловленности велики.
Точные значения `k` отделяющие разделяющие хорошо и плохо обусловленные задачи 
условно.
Лучше воспринимать число обусловленности как меру числа знаков,
которые становятся ошибочными после вычислений.
Например, если число обусловленности равно `1000`, то после
вычисления функции число верных знаков в десятичной записи уменьшается на три.
Значения `k`, для которых решение задачи имеет смысл, зависит
от точности исходных данных, числа применений функции, желаемой точности 
результат и т.п.

Число обусловленности позволяяет оценить сверху точность вычисления 
функции, безотносительно к алгоритму вычисления функции.
Никакой алгоритм на может дать результат вычисления функции точнее
чем `k` машинных точностей, если число обусловленности функции `k`,
а аргумент имел машинную точность.

Вычислим числа обусловленности для элементарных функций.

```
k(x^a)=x*(x^a)'/(x^a)=x*a*x^(a-1)/x^a=a.
```

Результат для степенной функции совпал с полученным ранее результатом,
в частности точность результата одна для всех чисел.
Можно отметить, что вычисление обратного `1/x` в точной арифметике 
может быть выполнено без потери точности.

Погрешность вычислений показательной функции увеличивается с 
ростом аргумента.
Случай `a=1` (постоянная функция) показывает, что
погрешность результата может быть много меньше погрешности аргумента.

```
k(a^x)=x*(a^x)'/(a^x)=x*(ln a)*a^x/a^x=x*ln a.
```

Рассмотрим погрешность вычисления тригонометрических функций:

```
k(sin x)=|x*(sin x)'/(sin x)|=|x*ctg x|,
k(cos x)=|x*(cos x)'/(cos x)|=|x*tg x|,
k(tg x)=|x*(tg x)'/(tg x)|=|x/sin x/cos x|,
k(ctg x)=|x*(ctg x)'/(ctg x)|=|x/sin x/cos x|,
k(arctg x)=|x*(arctg x)'/(arctg x)|=|x/(1+x^2)/arctg x|.
```

Результат вычисления тригонометрической функции может иметь 
бесконечно большую погрешность, если значение функции обращается в нуль.
Ясно что это общий факт: исходя из определения относительной погрешности видно,
что относительная погрешность стремится к бесконечности,
если точное значение стремится к нулю.

Выше мы рассмотрели функции одного аргумента, однако арифметические операции
зависят от двух аргументов.
Понятие числа обусловленности можно перенести на случай нескольких аргументов,
однако в этом случает нужно уточнить, что именно подразумевается под
точностью аргумента, так как каждый аргумент может иметь свою точность.
В качестве примера рассмотрим точность вычисления умножения.
Пусть `x=x0*(1+dx)` и `y=y0*(1+dy)` даны приближенно,
тогда их произведение равно

```
x*y=x0*y0*(1+dx)*(1+dy)=(x0*y0)*(1+dx+dy+dx*dy),
```

где слагаемым `dx*dy` можно пренебречь, так как оно меньшего порядка,
чем `dx` и `dy`.
Из полученной формулы мы заключаем, что относительная погрешность 
произведения равна сумме погрешностей аргументов `dx+dy`.
Можно сказать, что погрешность результата пропорциональна некоей функии
от погрешностей аргументов, в математике эта функци называется нормой.
В случае одной переменной роль нормы играл модуль числа,
в случае нескольких переменных функция определена неоднозначно,
например, можно рассмотреть `L-1` норму `|(dx,dy)|=|dx|+|dy|`
или `L-бесконечноть` норму `max(|dx|,|dy|)`.
Числа обусловленности для разных норм могут различаться, например,
для `L-1` нормы число обусловленности равно `1`,
а для `L-бесконечность` нормы число обусловленности равно `2`.

```
|dx+dy|<=|dx|+|dy|<=2*max(|dx|,|dy|).
```

Оценим теперь относительную погрушность операции вычитания для тех же чисел `x` и `y`:

```
|(x-y)-(x0-y0)|/|x0-y0|=|x0*dx-y0*dy|/|x0-y0|<=|dx|*|x0|/|x0-y0|+|dy|*|y0|/|x0-y0|
<=max(|dx|,|dy|)*(|x0|+|y0|)/|x0-y0|.
```

Неравенство выше показывает, что число обусловленности для вычитания в
`L-бесконечность` норме равно

```
k(x0,y0)=(|x0|+|y0|)/|x0-y0|.
```

Так как числитель всегда больше знаменателя, то число обусловленности
для вычитания всегда не меньше единицы.
Более того, если вычитаемые значения близки, то знаменатель близок к нулю,
и число обусловленности может быть сколь угодно велико.
Этот эффект, называемый *катастрофическим сокращением*, демонстрирует,
что даже одна операция над приближенными значенями может
радикально увеличить погрешность вычислений.

Так как вычитание отличается от сложения только знаками аргументов,
а мы не делали никаких предположений на знаки, то
приведенная выше оценка также работает для сложения, но нужно изменить знак `y0`,
тем самым получаем число обусловленности для сложения.

```
k(x0,y0)=(|x0|+|y0|)/|x0+y0|.
```

Легко видеть, что если оба аргумента положительны, то число обусловленности равно `1`,
т.е. при сложении положительных аргументов точность не изменяется.
Отсюда можно предположить, что положительные числа можно складывать 
не задумываясь о точности, однако это не так.
В качестве примера рассмотрим сумму числа `1` и `10^n` чисел `10^(-n)`
в арифметике с плавающей запятой.
Сумма этих чисел должна быть равна `2`,
однако при сложеннии `1` и `10^(-n)` результат равен `1`, если
второе число меньше машинной точности,
т.е. начиная суммирование с `1` мы получаем в арифметике с плавающей запятой
суммы равную `1`.
Однако, если начать суммирование с меньших слагаемых, то точность будет выше.

## Вопросы для закрепления

1. Какова погрешность вычисления `1/pi` в арифметике с плавающей запятой?
Учтите погрешность округления `pi` до числа с плавающей запятой,
погрешность выполнения операция деления над числами с плавающей запятой
и изменении погрешности при вычислении обратного.
1. Сравните точность вычисления `a/b` и `a*(1/b)`.
1. Какой способ вычислений предпочтительнее:
`log(a/b)` или `log(a)-log(b)`?
1. Как согласуется существование эффекта катастрофического сокращения
и требование стандарта IEEE 754, предписывающее операции вычитания
возвращать результат с погрешностью, не превосходящей машинной точности?

## Литература

1. [Numerical recipes.](http://numerical.recipes/) 
The art of scientific computing. 1256 pp.
Cambridge University Press (2007).
